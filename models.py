"""Pydantic models for request/response validation."""
from typing import List, Optional, Literal
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field


# =============================================================================
# MVP Vocabulary Scope: LCSH and FAST only
# Other vocabularies (GTT, RERO, SWD, etc.) are optional/future extensions
# =============================================================================

class VocabularyType(str, Enum):
    """Supported vocabulary types for MVP."""
    LCSH = "lcsh"  # Library of Congress Subject Headings
    FAST = "fast"  # Faceted Application of Subject Terminology
    # Future extensions (not auto-generated in MVP):
    # GTT = "gtt"
    # RERO = "rero"
    # SWD = "swd"
    # IDSZBZ = "idszbz"
    # RAM = "ram"


class SubjectStatus(str, Enum):
    """Status of a subject heading in the workflow."""
    SUGGESTED = "suggested"      # AI-generated suggestion
    SELECTED = "selected"        # Librarian selected
    REJECTED = "rejected"        # Librarian rejected
    MODIFIED = "modified"        # Librarian modified
    IMPORTED = "imported"        # From existing record


class PageImage(BaseModel):
    """Represents a single page image with optional hint."""
    page_hint: Optional[str] = Field(None, description="Client-side page type hint")
    page_type: Optional[str] = Field(None, description="Detected page type")
    text: str = Field(default="", description="Extracted text from page")


class BookMetadata(BaseModel):
    """Extracted book metadata from OCR."""
    title: str = Field(..., description="Book title")
    author: str = Field(default="", description="Author name(s)")
    publisher: str = Field(default="", description="Publisher name")
    pub_place: str = Field(default="", description="Publication place")
    pub_year: str = Field(default="", description="Publication year")
    summary: str = Field(default="", description="Summary text from back cover/flap")
    table_of_contents: List[str] = Field(default_factory=list, description="Table of contents entries")
    preface_snippets: List[str] = Field(default_factory=list, description="Preface text snippets")
    raw_pages: List[PageImage] = Field(default_factory=list, description="Raw page classifications and text")


class TopicCandidate(BaseModel):
    """A semantic topic candidate generated by LLM."""
    topic: str = Field(..., description="Natural language topic statement")
    type: Literal["topical", "geographic", "genre"] = Field(default="topical", description="Topic type")


class AuthorityCandidate(BaseModel):
    """An authority heading match from any vocabulary."""
    label: str = Field(..., description="Authority label")
    uri: str = Field(..., description="Authority URI (id.loc.gov, FAST, etc.)")
    vocabulary: str = Field(..., description="Vocabulary source (lcsh, fast, gtt, rero, swd, etc.)")
    score: float = Field(..., description="Vector search score")


class LCSHMatch(AuthorityCandidate):
    """Legacy LCSH match model for backwards compatibility."""
    certainty: Optional[float] = Field(None, description="Vector search certainty score (deprecated, use score)")
    
    def __init__(self, **data):
        if 'certainty' in data and 'score' not in data:
            data['score'] = data['certainty']
        if 'vocabulary' not in data:
            data['vocabulary'] = 'lcsh'
        super().__init__(**data)


class TopicMatchResult(BaseModel):
    """Result of matching a topic to authority headings."""
    topic: str = Field(..., description="Original semantic topic")
    topic_type: str = Field(default="topical", description="Topic type")
    authority_candidates: List[AuthorityCandidate] = Field(default_factory=list, description="Authority matches from all vocabularies")
    matches: List[LCSHMatch] = Field(default_factory=list, description="Legacy LCSH matches (deprecated)")


class Subfield(BaseModel):
    """A single MARC subfield."""
    code: str = Field(..., description="Subfield code (a, x, y, z, v, 0, 2, etc.)")
    value: str = Field(..., description="Subfield value")


# Alias for backward compatibility
MARCSubfield = Subfield


class Subject65X(BaseModel):
    """
    Subject heading model for 65X fields (650/651/655).
    
    This is the primary model for subject headings in the system.
    Supports LCSH and FAST vocabularies for MVP.
    
    Examples:
        LCSH:  650 _0 $a Calligraphy, Chinese $y Ming-Qing dynasties, 1368-1912.
        FAST:  650 _7 $a Calligraphy, Chinese $2 fast $0 (OCoLC)fst00844437
    """
    # MARC field structure
    tag: Literal["650", "651", "655"] = Field(..., description="MARC tag: 650 (topical), 651 (geographic), 655 (genre/form)")
    ind1: str = Field(default="_", description="First indicator (usually blank)")
    ind2: str = Field(..., description="Second indicator: 0=LCSH, 7=other vocabulary")
    
    # Vocabulary identification
    vocabulary: Literal["lcsh", "fast"] = Field(..., description="Vocabulary source: 'lcsh' or 'fast'")
    
    # Heading content
    heading_string: str = Field(..., description="Full heading string (e.g., 'China -- History -- Ming dynasty, 1368-1644')")
    subfields: List[Subfield] = Field(..., description="Parsed subfields [{code, value}, ...]")
    
    # Authority linking
    uri: Optional[str] = Field(None, description="Authority URI (id.loc.gov or FAST URI)")
    authority_id: Optional[str] = Field(None, description="Authority record ID")
    
    # Source and scoring
    source_system: str = Field(default="ai_generated", description="Source: 'ai_generated', 'imported', 'manual'")
    score: Optional[float] = Field(None, description="Confidence score from vector search (0-1)")
    
    # Cataloger support
    explanation: str = Field(default="", description="Natural language explanation for cataloger")
    
    # Workflow status
    status: SubjectStatus = Field(default=SubjectStatus.SUGGESTED, description="Status in workflow")
    
    def to_marc_string(self) -> str:
        """Convert to MARC format string."""
        result = f"{self.tag} {self.ind1}{self.ind2}"
        for sf in self.subfields:
            result += f" ${sf.code} {sf.value}"
        return result + "."
    
    def get_subfield(self, code: str) -> Optional[str]:
        """Get value of a specific subfield."""
        for sf in self.subfields:
            if sf.code == code:
                return sf.value
        return None
    
    @classmethod
    def get_ind2_for_vocabulary(cls, vocabulary: str) -> str:
        """Get second indicator based on vocabulary."""
        return "0" if vocabulary == "lcsh" else "7"
    
    class Config:
        use_enum_values = True


# Alias for backward compatibility
MARCField65X = Subject65X


class MARCField650(BaseModel):
    """Legacy MARC 650 field representation (kept for backwards compatibility)."""
    tag: str = Field(default="650", description="MARC tag")
    ind1: str = Field(default="_", description="First indicator")
    ind2: str = Field(default="0", description="Second indicator")
    subfield_a: str = Field(..., description="Main subject heading")
    subfield_x: Optional[str] = Field(None, description="General subdivision")
    subfield_y: Optional[str] = Field(None, description="Chronological subdivision")
    subfield_z: Optional[str] = Field(None, description="Geographic subdivision")
    subfield_0: Optional[str] = Field(None, description="Authority record control number (URI)")
    
    def to_marc_string(self) -> str:
        """Convert to MARC format string."""
        result = f"{self.tag} {self.ind1}{self.ind2}"
        result += f" $a {self.subfield_a}"
        if self.subfield_x:
            result += f" $x {self.subfield_x}"
        if self.subfield_y:
            result += f" $y {self.subfield_y}"
        if self.subfield_z:
            result += f" $z {self.subfield_z}"
        if self.subfield_0:
            result += f" $0 {self.subfield_0}"
        return result + "."
    
    def to_65x(self) -> MARCField65X:
        """Convert to new 65X format."""
        subfields = [MARCSubfield(code="a", value=self.subfield_a)]
        if self.subfield_x:
            subfields.append(MARCSubfield(code="x", value=self.subfield_x))
        if self.subfield_y:
            subfields.append(MARCSubfield(code="y", value=self.subfield_y))
        if self.subfield_z:
            subfields.append(MARCSubfield(code="z", value=self.subfield_z))
        if self.subfield_0:
            subfields.append(MARCSubfield(code="0", value=self.subfield_0))
        
        return MARCField65X(
            tag=self.tag,
            ind1=self.ind1,
            ind2=self.ind2,
            subfields=subfields,
            vocabulary="lcsh" if self.ind2 == "0" else "unknown",
            uri=self.subfield_0
        )


class FinalRecord(BaseModel):
    """Complete record for storage."""
    uuid: str = Field(..., description="Unique record identifier")
    metadata: BookMetadata = Field(..., description="Extracted book metadata")
    ai_topics: List[TopicCandidate] = Field(default_factory=list, description="AI-generated topics")
    lcsh_matches: List[TopicMatchResult] = Field(default_factory=list, description="Authority matches for topics")
    subjects_65x: List[Subject65X] = Field(default_factory=list, description="65X subject headings (LCSH + FAST)")
    # Legacy fields for backward compatibility
    librarian_selected: List[LCSHMatch] = Field(default_factory=list, description="Librarian-confirmed selections (legacy)")
    marc_fields: List[MARCField650] = Field(default_factory=list, description="Generated MARC 650 fields (legacy)")
    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat(), description="Creation timestamp")


class IngestImagesResponse(BaseModel):
    """Response from image ingestion endpoint."""
    success: bool
    metadata: BookMetadata
    message: Optional[str] = None


class GenerateTopicsRequest(BaseModel):
    """Request for topic generation."""
    metadata: BookMetadata


class GenerateTopicsResponse(BaseModel):
    """Response from topic generation."""
    success: bool
    topics: List[TopicCandidate]
    message: Optional[str] = None


class LCSHMatchRequest(BaseModel):
    """Request for LCSH matching."""
    topics: List[str]


class LCSHMatchResponse(BaseModel):
    """Response from LCSH matching."""
    success: bool
    matches: List[TopicMatchResult]
    message: Optional[str] = None


class MARC650Request(BaseModel):
    """Request for MARC 650 generation."""
    lcsh_selections: List[LCSHMatch]


class Build65XRequest(BaseModel):
    """Request for 65X MARC generation."""
    topics_with_candidates: List[TopicMatchResult]


class Build65XResponse(BaseModel):
    """Response from 65X MARC generation."""
    success: bool
    subjects_65x: List[Subject65X]
    message: Optional[str] = None


class MARC650Response(BaseModel):
    """Response from MARC 650 generation (legacy)."""
    success: bool
    marc_fields: List[MARCField650]
    message: Optional[str] = None


class SubmitFinalRequest(BaseModel):
    """Request for final submission."""
    metadata: BookMetadata
    ai_topics: List[TopicCandidate]
    lcsh_matches: List[TopicMatchResult]
    librarian_selected: List[LCSHMatch]
    marc_fields: List[MARCField650]
    subjects_65x: Optional[List[Subject65X]] = Field(default_factory=list, description="65X subject headings")


class SubmitFinalResponse(BaseModel):
    """Response from final submission."""
    success: bool
    uuid: str
    file_path: Optional[str] = None
    message: Optional[str] = None
